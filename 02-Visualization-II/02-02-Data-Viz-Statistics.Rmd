---
title: "Statistics layer"
subtitle: "Data Visualization - Part 5"
output: html_notebook
---

```{r include=FALSE}
# loading libraries
library(tidyverse)

# modifying chart size
options(repr.plot.width=5, repr.plot.height=3)
```

<center> ![](../png/layers-of-ggplot.png){width=400} </center>

Next, let's take a look at a bar chart. Bar charts seem simple, but they are interesting because they reveal something subtle about plots. Consider a basic bar chart, as drawn with `geom_bar()`. The following chart displays the total number of diamonds in the `diamonds` dataset, grouped by `cut`. The `diamonds` dataset comes in ggplot2 and contains information about ~54,000 diamonds, including the `price`, `carat`, `color`, `clarity`, and `cut` of each diamond. The chart shows that more diamonds are available with high quality cuts than with low quality cuts.

```{r}
head(diamonds)
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

On the x-axis, the chart displays `cut`, a variable from `diamonds`. On the y-axis, it displays count, but count is not a variable in diamonds! The algorithm used to calculate new values for a graph (count here) is called a **stat**, short for statistical transformation. The figure below describes how this process works with `geom_bar()`.

<center> ![](../png/visualization-stat-bar.png){width=800} </center>

You can learn which stat a geom uses by inspecting the default value for the `stat` argument. For example, `?geom_bar` shows that the default value for `stat` is "count", which means that `geom_bar()` uses `stat_count()`.

You can generally use geoms and stats interchangeably. For example, you can recreate the previous plot using `stat_count()` instead of `geom_bar()`:

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))
```

This works because every geom has a default stat; and every stat has a default geom. This means that you can typically use geoms without worrying about the underlying statistical transformation. There are three reasons you might need to use a stat explicitly:

**1)** You want to create a bar chart from the raw data:

```{r}
demo <- data.frame(X=c("a","b","c","d"),
           Y=sample(5:20, 4, replace=FALSE))

demo
```

```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = X, y = Y), stat = "identity")
```


Or we could use `geom_col()`; the default stat function for `geom_col()` is "identity", so no need to specify it:

```{r}
ggplot(data = demo) +
  geom_col(mapping = aes(x = X, y = Y))
```

**2)** You might want to override the default mapping from transformed variables to aesthetics. For example, you might want to display a bar chart of proportion, rather than count:

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
```

If `group` is not set to 1, then all the bars have `prop == 1`. `group = 1` here means to find the proportions across all of the groups, rather than within each group. The function `geom_bar()` assumes that the groups are equal to the `x` values, since the `stat` computes the counts within the group.

**3)** You might want to draw greater attention to the statistical transformation in your code. For example, you might use stat_summary(), which summarizes the y values for each unique x value, to draw attention to the summary that you're computing:

```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )
```